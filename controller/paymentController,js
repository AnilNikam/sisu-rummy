const mongoose = require('mongoose');
const MongoID = mongoose.Types.ObjectId;
const paymentin = mongoose.model('paymentin');
const paymentout = mongoose.model('paymentout');
const GameUser = mongoose.model('users');
const crypto = require('crypto');
const axios = require('axios');
const commandActions = require('../helper/socketFunctions');
const walletActions = require('../helper/common-function/walletTrackTransaction');
const CONST = require('../constant');
const logger = require('../logger');

const algorithm = "aes-128-cbc";
const authKey = "0jeOYcu3UnfmWyLC";
const authIV = "C28LAmGxXTqmK0QJ";


const PaymentInOrderCreate = {
    url: 'https://api.wowpe.in/api/GOrders/generateorder',
    token: "250066b4-3b16-4b6f-a76e-d5478f701ef5",
    secret_key: '04d34b84-e065-42a7-bbef-795965535275',
};

const PaymentInDeepLink = {
    url: 'https://api.wowpe.in/api/DeepLinks/intentinitiate',
    token: "250066b4-3b16-4b6f-a76e-d5478f701ef5",
    secret_key: '04d34b84-e065-42a7-bbef-795965535275',
};

async function starPaisaPayment(requestData, socket) {
    try {
        logger.info("Initiate Payment requestData", requestData);

        // Validate requestData
        if (!requestData.amount || !requestData.playerId || !requestData.customerName || !requestData.customerEmail || !requestData.customerPhone) {
            throw new Error('Missing required fields in requestData');
        }

        const amountNumber = parseFloat(requestData.amount);
        if (isNaN(amountNumber) || amountNumber <= 0) {
            throw new Error('Invalid amount value');
        }

        logger.info("Amount", amountNumber.toFixed(2));

        const reference = generateReferenceNumber();
        logger.info("Reference", reference);

        const formattedDate = formatDate(new Date().toISOString());
        logger.info("Formatted Date", formattedDate);

        // Create payment record in database
        const paymentData = await paymentin.create({
            userId: requestData.playerId,
            transactionId: reference,
            name: requestData.customerName,
            email: requestData.customerEmail,
            phone: requestData.customerPhone,
            amount: requestData.amount,
            paymentGateway: 'starPaisa',
            paymentStatus: "Pending"
        });

        if (paymentData) {
            logger.info("Payload paymentData =>", paymentData);

            const payload = { amount: requestData.amount };
            const stringifiedPayload = JSON.stringify(payload);
            logger.info("Stringified Payload Star pay payload =>", stringifiedPayload);

            try {
                const response = await axios.post(
                    'https://api.starpaisa.in/v1/merchant/generateQR',
                    stringifiedPayload,
                    {
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': 'Basic cmFodWxzaW5naGF4aXMxQGdtYWlsLmNvbTpUcmFpbkA0OTEwNzI='
                        }
                    }
                );

                const responseData = response.data;
                logger.info('Response:', responseData);

                if (responseData.statusCode === 200) {
                    if (responseData.data.status === "SUCCESS") {
                        commandActions.sendEvent(socket, CONST.PAY_IN, responseData.data, true, 'Payment initiated successfully');

                        // Update OrderID in payment record
                        const updatedOrder = await paymentin.findOneAndUpdate(
                            { _id: paymentData._id },
                            { $set: { "OrderID": responseData.data.extTransactionId } },
                            { new: true }
                        );
                        logger.info("Updated Order ID =>", updatedOrder);
                    } else {
                        commandActions.sendEvent(socket, CONST.PAY_IN, {}, false, responseData.data.respMessage || 'Payment initiation failed');
                    }
                } else {
                    commandActions.sendEvent(socket, CONST.PAY_IN, {}, false, responseData.message || 'Something went wrong. Please try again');
                }
            } catch (error) {
                logger.error("Payin error =>", error.response ? error.response.data : error.message);
                commandActions.sendEvent(socket, CONST.PAY_IN, {}, false, 'Something went wrong. Please try again');
            }
        } else {
            logger.info("Data not inserted");
            commandActions.sendEvent(socket, CONST.PAY_IN, {}, false, 'Something went wrong. Please try again');
        }

    } catch (error) {
        logger.error('Error initiating payment:', error.response ? error.response.data : error.message);
        commandActions.sendEvent(socket, CONST.PAY_IN, {}, false, 'Something went wrong. Please try again');
        throw error; // Throw the error to be caught by the caller if necessary
    }
}

async function initiatePayment(requestData, socket) {
    try {
        logger.info("initiatePayment requestData ", requestData)
        const paymentindata = await paymentin.create({
            userId: requestData.playerId,
            transactionId: "aaa",
            name: requestData.customerName,
            email: requestData.customerEmail,
            phone: requestData.customerPhone,
            amount: requestData.amount,
            paymentStatus: "Pending"
        });

        if (paymentindata) {

            logger.info("paymentindata ", paymentindata)
            const payload = {
                "token": PaymentInOrderCreate.token,
                "name": requestData.customerName,
                "mobileNo": requestData.customerPhone,
                "emailID": requestData.customerEmail,
                "amount": requestData.amount,
                "orderInfo": paymentindata._id.toString()
            };

            const response = await axios.post(PaymentInOrderCreate.url, payload);
            logger.info("response    ", response.data)
            if (response.data.code == "OK") {
                //add amount in coins

                //await walletActions.addWallet(tableInfo.gameTracks[i]._id, Number(winnerTrack.winningAmount), 'Credit', 'Win', tableInfo);
                if (response.data.body != undefined && response.data.body != null && response.data.body.orderID != undefined) {

                    const Updatedata = await paymentin.findOneAndUpdate({ _id: MongoID(paymentindata._id.toString()) }, { $set: { "OrderID": response.data.body.orderID } }, {
                        new: true,
                    });
                    logger.info("Updatedata ", Updatedata)
                    const payloaddeeplink = {
                        "note": "rechargeMoney_103",
                        "OrderID": response.data.body.orderID,
                        "token": PaymentInOrderCreate.token
                    }

                    const responseDeep = await axios.post(PaymentInDeepLink.url, payloaddeeplink);
                    logger.info("response Deeplink ", responseDeep.data)
                    commandActions.sendEvent(socket, CONST.PAY_IN, responseDeep.data);

                } else {
                    commandActions.sendEvent(socket, CONST.PAY_IN, {}, false, response.data.message);
                }
            } else {
                commandActions.sendEvent(socket, CONST.PAY_IN, {}, false, response.data.message);
            }
        } else {
            logger.info("Data Not Insert ")
            commandActions.sendEvent(socket, CONST.PAY_IN, {}, false, 'Something Went Wrong Please try again');
        }

    } catch (error) {
        console.error('Error initiating payment:', error.response ? error.response.data : error.message);

        commandActions.sendEvent(socket, CONST.PAY_IN, {}, false, 'Something Went Wrong Please try again');

        throw error; // Throw the error to be caught by the caller
    }
}

async function newInitiatePayment(requestData, socket) {
    try {
        logger.info("initiatePayment requestData ", requestData)
        const amountNumber = parseFloat(requestData.amount);
        logger.info("amount ", amountNumber)
        logger.info("amount check ", amountNumber.toFixed(2))
        const reference = generateReferenceNumber()
        logger.info("reference ", reference)
        const formateDate = formatDate(new Date().toISOString())
        logger.info("formateDate ", formateDate)


        const paymentindata = await paymentin.create({
            userId: requestData.playerId,
            transactionId: reference,
            name: requestData.customerName,
            email: requestData.customerEmail,
            phone: requestData.customerPhone,
            amount: requestData.amount,
            paymentGateway: 'paylotus',
            paymentStatus: "Pending"
        });

        if (paymentindata) {

            logger.info("payload paymentindata =>", paymentindata)

            const payload = {
                "AuthID": "M00006500",
                "AuthKey": "WW0DN9DY8ji8mE0sx9Zf4Lg1sp9xY9wF",
                "CustRefNum": reference,
                "txn_Amount": amountNumber.toFixed(2),
                "PaymentDate": formateDate,
                "ContactNo": requestData.customerPhone,
                "EmailId": requestData.customerEmail,
                "IntegrationType": "seamless",
                "CallbackURL": "https://rummylegit.com:3000/admin/api/PayinAPI/newPayInNotify",
                "adf1": "NA",
                "adf2": "NA",
                "adf3": "NA",
                "MOP": "UPI",
                "MOPType": "UPI",
                "MOPDetails": "I"
            };


            const stringifiedPayload = JSON.stringify(payload, null, 2)
            logger.info("stringifiedPayload payload =>", stringifiedPayload);


            const data = stringifiedPayload;
            const secretKey = 'WW0DN9DY8ji8mE0sx9Zf4Lg1sp9xY9wF';
            const initializationVector = 'WW0DN9DY8ji8mE0s';

            const encryptedData = encrypt(data, secretKey, initializationVector);
            logger.info('Encrypted data:', encryptedData);
            try {
                const response = await axios.post('https://live.paylotus.in/pay/paymentinit?AuthID=M00006500&encData=' + encryptedData);
                logger.info('Response:', response);

                if (response.data && response.data.respData) {
                    const receivedEncryptedData = response.data.respData;
                    const decryptedData1 = decrypt(receivedEncryptedData, secretKey, initializationVector);
                    logger.info('Decrypted data:', decryptedData1);
                    const decryptedData = JSON.parse(decryptedData1);
                    logger.info("final Response -> ", decryptedData);

                    if (decryptedData && decryptedData.AggRefNo !== undefined && decryptedData.AggRefNo !== null) {
                        commandActions.sendEvent(socket, CONST.PAY_IN, decryptedData);
                        let upOrderId = await paymentin.findOneAndUpdate({ _id: MongoID(paymentindata._id.toString()) }, { $set: { "OrderID": decryptedData.AggRefNo } }, { new: true });
                        logger.info("Update Order Id =>", upOrderId)
                    } else {

                        commandActions.sendEvent(socket, CONST.PAY_IN, {}, false, decryptedData);
                    }
                } else {
                    logger.info('Response data or respData not found:', response);
                }
            } catch (error) {
                logger.error("check Payin error =>", error)
            }
        } else {
            logger.info("Data Not Insert ")
            commandActions.sendEvent(socket, CONST.PAY_IN, {}, false, 'Something Went Wrong Please try again');
        }

    } catch (error) {
        console.error('Error initiating payment:', error.response ? error.response.data : error.message);

        commandActions.sendEvent(socket, CONST.PAY_IN, {}, false, 'Something Went Wrong Please try again');

        throw error; // Throw the error to be caught by the caller
    }
}

async function sabPaisaInitiatePayment(requestData, socket) {
    try {
        let payerName = requestData.customerName;
        let payerEmail = requestData.customerEmail;
        let payerMobile = requestData.customerPhone;
        let clientTxnId = randomStr(20, "12345abcde");
        let amount = requestData.amount;
        let clientCode = "TM001";       // Please use the credentials shared by your Account Manager  If not, please contact your Account Manage
        let transUserName = "spuser_2013";      // Please use the credentials shared by your Account Manager  If not, please contact your Account Manage
        let transUserPassword = "RIADA_SP336";   // Please use the credentials shared by your Account Manager  If not, please contact your Account Manage
        const callbackUrl = "https://13.51.155.167:3001/admin/api/PayinAPI/getPgRes";
        const channelId = "W";
        const spURL = "https://stage-securepay.sabpaisa.in/SabPaisa/sabPaisaInit?v=1"; // Staging environment
        //let spURL = "https://uatsp.sabpaisa.in/SabPaisa/sabPaisaInit"; // UAT environment
        //  let spDomain = 'https://securepay.sabpaisa.in/SabPaisa/sabPaisaInit'; // production environment

        let mcc = "5666";
        let transData = new Date();

        let stringForRequest =
            "payerName=" +
            payerName +
            "&payerEmail=" +
            payerEmail +
            "&payerMobile=" +
            payerMobile +
            "&clientTxnId=" +
            clientTxnId +
            "&amount=" +
            amount +
            "&clientCode=" +
            clientCode +
            "&transUserName=" +
            transUserName +
            "&transUserPassword=" +
            transUserPassword +
            "&callbackUrl=" +
            callbackUrl +
            "&channelId=" +
            channelId +
            "&mcc=" +
            mcc +
            "&transData=" +
            transData;

        logger.info("stringForRequest :: " + stringForRequest);

        let encryptedStringForRequest = sabPaisaEncrypt(stringForRequest);
        logger.info("encryptedStringForRequest :: " + encryptedStringForRequest);

        const formData = {
            spURL: spURL,
            encData: encryptedStringForRequest,
            clientCode: clientCode,
        };

        res.render(__dirname + "/pg-form-request.html", { formData: formData });

    } catch (error) {
        logger.error('Error sabpaisa initiating payment:', error.response ? error.response.data : error.message);

        commandActions.sendEvent(socket, CONST.PAY_IN, {}, false, 'Something Went Wrong Please try again');

        throw error; // Throw the error to be caught by the caller
    }
}

const Account_WOWPE_PAYOUT = {
    // base_url: 'https://api.wowpe.in/api/PayoutAPI/paymenttransafer',//old
    base_url: 'https://api.wowpe.in/api/api/api-module/payout/payout',
    clientId: '4352f542-c412-4563-8292-bbe2d9a1a9ff',
    secretKey: 'a3ebf105-22cd-4f8d-9dff-bf1fd7a04b4c'
};

async function PayOutTransfer(requestData, socket) {
    try {

        logger.info(" Create PayOut Transfer =>", requestData);
        let query = { _id: MongoID(requestData.playerId) };
        let userDetails = await GameUser.findOne(query, {}).lean();
        logger.info("PayOutTransfer userDetails Transfer =>", userDetails);

        // Check if withdrawal amount is within the allowed range
        if (requestData.amount < 50 || requestData.amount > 1000) {
            commandActions.sendEvent(socket, CONST.CREATE_PAY_OUT, false, "Withdrawal amount must be between 50 and 1000.");
            return;
        }

        // Check if user has sufficient winning chips
        if (userDetails.winningChips < requestData.amount) {
            commandActions.sendEvent(socket, CONST.CREATE_PAY_OUT, false, "Insufficient Withdrawal Chips.");
            return;
        }

        // Check the number of withdrawals made today
        let startOfToday = new Date();
        startOfToday.setHours(0, 0, 0, 0);
        let endOfToday = new Date();
        endOfToday.setHours(23, 59, 59, 999);

        let withdrawalCount = await paymentout.countDocuments({
            userId: requestData.playerId,
            createdAt: { $gte: startOfToday, $lte: endOfToday }
        });
        logger.info("withdrawalCount->", withdrawalCount)
        if (withdrawalCount >= 5) {
            commandActions.sendEvent(socket, CONST.CREATE_PAY_OUT, false, "You can only withdraw 5 times per day.");
            return;
        }


        let redeemAmount = requestData.amount
        const reference = generateReferenceNumber()
        logger.info("PayOutTransfer reference==> ", reference)

        requestData.amount = requestData.amount - ((requestData.amount * 2) / 100)


        //Insert Payout Table 
        const paymentoutdata = await paymentout.create({
            userId: requestData.playerId,
            transactionId: reference,
            name: requestData.customerName,
            email: requestData.customerEmail,
            phone: requestData.customerPhone,
            amount: requestData.amount,
            accountNo: requestData.accountNo,
            ifscCode: requestData.ifscCode,
            redeemAmount: redeemAmount,
            paymentGateway: 'wowpe',
            "beneficiaryName": requestData.BeneficiaryName.trim(),
            "transferMode": requestData.transferMode,
            paymentStatus: "Pending"
        });

        if (paymentoutdata) {

            logger.info("payment out data  ==>", paymentoutdata)

            const Paylod = {
                "clientId": '4352f542-c412-4563-8292-bbe2d9a1a9ff',
                "secretKey": 'a3ebf105-22cd-4f8d-9dff-bf1fd7a04b4c',
                "number": requestData.customerPhone,
                "amount": requestData.amount.toString(),
                "transferMode": requestData.transferMode,
                "accountNo": requestData.accountNo,
                "ifscCode": requestData.ifscCode,
                "beneficiaryName": requestData.BeneficiaryName.trim(),
                "vpa": "",
                "clientOrderId": paymentoutdata._id.toString()
            }

            logger.info("check Paylod -->", Paylod)

            const response = await axios.post(Account_WOWPE_PAYOUT.base_url, Paylod, {
                headers: {
                    'Content-Type': 'application/json',
                    'accept': 'application/json'
                }
            });

            logger.info("get response init payout =>", response.data)

            if (response.data.statusCode == 1) {
                //add amount in coins
                logger.info("chec response data =======> ", response.data)
                //await walletActions.addWallet(tableInfo.gameTracks[i]._id, Number(winnerTrack.winningAmount), 'Credit', 'Win', tableInfo);
                if (response.data && response.data != null && response.data.orderId != undefined && response.data.orderId != null && response.data.status == 1) {

                    const Updatedata = await paymentout.findOneAndUpdate({ _id: MongoID(paymentoutdata._id.toString()) }, { $set: { "OrderID": response.data.clientOrderId } }, {
                        new: true,
                    });
                    logger.info("payout  Update data ", Updatedata)


                    commandActions.sendEvent(socket, CONST.CREATE_PAY_OUT, response.data);

                    //deduct user chips

                    await walletActions.deductWalletPayOut(requestData.playerId, -Number(redeemAmount), 'Debit', 'PayOut', 'Payment', 'wowPe');



                } else if (response.data.status == 2) {
                    logger.info("response elase 1 ", response.data)

                    const Updatedata = await paymentout.findOneAndUpdate({ _id: MongoID(paymentoutdata._id.toString()) }, { $set: { "OrderID": response.data.clientOrderId } }, {
                        new: true,
                    });
                    logger.info("payout Status Update data ", Updatedata)

                    commandActions.sendEvent(socket, CONST.CREATE_PAY_OUT, response.data);
                    await walletActions.deductWalletPayOut(requestData.playerId, -Number(redeemAmount), 'Debit', 'PayOut', 'Payment', 'wowPe');

                }

            } else {
                logger.info(" Response else ->", response.data)
                commandActions.sendEvent(socket, CONST.CREATE_PAY_OUT, {}, false, response.data);
            }
        } else {
            logger.info("Data Not Insert ")

            commandActions.sendEvent(socket, CONST.CREATE_PAY_OUT, {}, false, 'Something Went Wrong Please try again');

        }

    } catch (error) {
        logger.info("error ::::::::::::", error)

        throw error.response ? error.response.data : error.message;
    }
}

const Account_WOWPE_VERIFICATION = {
    base_url: 'https://api.wowpe.in/PayoutAPI/accountverification',
    clientId: 'aa482292-1675-444d-91d0-57d68829f560',
    secretKey: '5ccb3ea7-a7b1-4927-8fe6-a83bd6e5a330'
};

async function checkPayoutStatus(requestData, callback) {
    try {
        const Paylod = {
            "clientId": Account_WOWPE_VERIFICATION.clientId,
            "secretKey": Account_WOWPE_VERIFICATION.secretKey,
            "number": requestData.customerPhone,
            "accountNo": requestData.accountNo,
            "ifscCode": requestData.ifscCode,
            "orderID": requestData.orderID
        }
        logger.info("PayOut ::::::::::::::::::::::", Paylod)
        const response = await axios.post(Account_WOWPE_VERIFICATION.base_url, Paylod, {
            headers: {
                'Content-Type': 'application/json',
                'accept': 'application/json'
            }
        });
        logger.info("checkPayoutStatus ", response)
        return callback(response.data);
    } catch (error) {
        throw error.response ? error.response.data : error.message;
    }
}

function generateReferenceNumber() {
    // Create a string of all digits (0-9)
    const digits = '0123456789';

    // Generate a random string of 10 characters from the digits string
    let referenceNumber = '';
    for (let i = 0; i < 10; i++) {
        const randomIndex = Math.floor(Math.random() * digits.length);
        referenceNumber += digits[randomIndex];
    }

    return referenceNumber;
}

function formatDate(dateString) {
    const date = new Date(dateString);
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    const hours = String(date.getHours()).padStart(2, '0');
    const minutes = String(date.getMinutes()).padStart(2, '0');
    const seconds = String(date.getSeconds()).padStart(2, '0');

    return `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;
}

function encrypt(data, key, iv) {
    try {
        const cipher = crypto.createCipheriv('aes-256-cbc', Buffer.from(key), iv);
        let encrypted = cipher.update(data, 'utf8', 'base64'); // Update with base64 encoding
        encrypted += cipher.final('base64');
        return encrypted;
    } catch (error) {
        console.error('Encryption error:', error);
        throw error; // Re-throw for handling in caller
    }
}

// Function to decrypt data using AES/CBC/PKCS5PADDING
function decrypt(encryptedData, key, iv) {
    try {
        const decipher = crypto.createDecipheriv('aes-256-cbc', Buffer.from(key), iv);
        let decrypted = decipher.update(encryptedData, 'base64', 'utf8');
        decrypted += decipher.final('utf8');
        return decrypted;
    } catch (error) {
        console.error('Decryption error:', error);
        throw error; // Re-throw for handling in caller
    }
}


function sabPaisaEncrypt(text) {
    let cipher = crypto.createCipheriv(algorithm, Buffer.from(authKey), authIV);
    let encrypted = cipher.update(text);
    encrypted = Buffer.concat([encrypted, cipher.final()]);
    return encrypted.toString("base64");
}

function sabPaisaDecrypt(text) {
    // let iv = Buffer.from(text.iv, 'hex');
    // let encryptedText = Buffer.from(text.encryptedData, 'hex');
    let decipher = crypto.createDecipheriv(
        algorithm,
        Buffer.from(authKey),
        authIV
    );
    let decrypted = decipher.update(Buffer.from(text, "base64"));
    decrypted = Buffer.concat([decrypted, decipher.final()]);
    return decrypted.toString();
}

//generate random string
function randomStr(len, arr) {
    let ans = "";
    for (let i = len; i > 0; i--) {
        ans += arr[Math.floor(Math.random() * arr.length)];
    }
    return ans;
}


module.exports = {
    initiatePayment,
    PayOutTransfer,
    checkPayoutStatus,
    newInitiatePayment,
    generateReferenceNumber,
    starPaisaPayment,
    encrypt,
    decrypt,
    sabPaisaInitiatePayment,
    sabPaisaEncrypt,
    sabPaisaDecrypt
    // createPayout,
    // checkPayoutStatus,
    // getAccountBalance
};


